# PinPod & BoM Integrated Architecture

This document serves as a key technical architecture guide, synthesizing concepts from the BoM and PinPod into a cohesive ecosystem.

## Executive Summary

The PinPod ecosystem is designed as a Hybrid Web 2.5 platform, combining the speed and accessibility of Web 2.0 applications with the security and decentralization of Web 3.0 technologies.

- PinPod is the user-facing application layer, built using Flutter for mobile (Android/iOS) and web platforms. It is the "face" of the ecosystem.
- The BoM (Book of Memes) is the behind-the-scenes logic layer, serving as the "brain" or "intelligent agent" built using Python. The BoM handles complex data processing, core business logic, and interaction with the decentralized network.

- Both are connected by **Supabase** as a centralized data layer and **IPFS** as a decentralized storage layer.

## Core Architecture (Hybrid Web 2.5)

This hybrid approach is taken to maximize the benefits of both worlds:

1. **Speed (Web 2.0):** A responsive user experience is a priority. Therefore, all key data requiring fast queries (user profiles, service lists, transactions) is indexed and stored in a **PostgreSQL** database managed by **Supabase**.
2. **Ownership & Immutability (Web 3.0):** Core user-generated content ("Beans"), such as files, images, or important documents, is stored in **IPFS (InterPlanetary File System)**. This ensures that the data is immutable and ownership is clear, with only the *hash* (CID) of the content stored in Supabase.

## Component Details

| Component | Role | Technology | Hosting | 
| :--- | :--- | :--- | :--- | 
| **PinPod App** | Application Layer (Frontend) | Flutter | User Device (Mobile/Web) | 
| **BoM Agent** | Logic Layer (Backend) | Python, Docker | Google Cloud Run | 
| **Supabase** | Data Layer (Database) | PostgreSQL | Supabase Cloud | 
| **IPFS** | Storage Layer (File Storage) | IPFS Protocol | Pinata (or node itself) | 
| **Web Scanner** | Public Explorer | Next.js/React | Vercel | 

### 1. PinPod (The Application Layer)

This Flutter app is where all user interactions occur. Follows the "Tree of Life" architecture:

- **Root:** Connects to Supabase for basic data and Firebase for authentication.
- **Trunk:** Manages the application state (using Riverpod/Bloc) and user flow logic.
- **Crown (UI):** Displays different interfaces for "Seekers" (PINs) and "Providers" (PODs), as well as a dashboard, interactive map, and service creation form ("Bean").

### 2. BoM (The Logic Layer)

This Python agent is a data processing engine. It has no direct user interface but provides services through an API:

- **Encryption & Hashing:** Secures data and ensures integrity using the BLAKE3 algorithm.
- **Semantic Processing:** Runs the "DNA" and "Lexicon" algorithms to categorize and correlate data.
- **IPFS Interaction:** Manages file uploads to IPFS (via services like Pinata) and returns the CID for storage in Supabase.
- AI Services: Integrates with LLM models (such as OpenAI) to provide intelligent features within the PinPod app (e.g., generating product descriptions).

### 3. Supabase (The Data Layer)

Acts as a "Map" or "Index" for the entire ecosystem. It is a *single source of truth* for structured and frequently accessed data.

- Main Tables: `users`, `pods` (stores), `beans` (services/products), `transactions`.
- BoM Integration: Stores metadata and IPFS hashes (CIDs) generated by the BoM.
- Security: Uses Row-Level Security (RLS) to ensure users can only access their own data.

### 4. IPFS (The Storage Layer)

Serves as an immutable "repository" for digital content.

- **What's Stored:** An image, video, PDF, or other digital asset file that is part of a "Bean".
- **Flow:** The PinPod app sends the file to the BoM Agent, which then "pins" the file to IPFS via Pinata and returns the CID.

## Interaction Model & Data Flow

The main data flow is as follows:

**Scenario: User (Provider) Creates a New Service ("Bean")**

1. **PinPod App:** The user fills out a form in the app (description, price) and uploads an image.
2. **API Call to BoM:** The app sends the form data and image file to the **BoM Agent** via an API call (HTTP POST).
3. **BoM Agent - Internal Process:**
a. Receives data.
b. Uploads the image file to **IPFS** and obtains the `image_cid`.
c. Create a hash of all "Bean" data using BLAKE3 for `integrity_hash`.
d. (Optional) Call **LLM** to suggest a better description.
4. **BoM Agent -> Supabase:** The agent stores all metadata, `image_cid`, and `integrity_hash` into the `beans` table in **Supabase**.
5. **Supabase -> PinPod App:** The PinPod app, which listens for changes to the `beans` table (via Supabase Realtime), automatically exposes the new service in the user interface.

## Implementation & Deployment Strategy

1. **Frontend (Web Scanner):** Build the `scane.ioi.coin` application using **Next.js** and deploy it on **Vercel**. This will be a public "storefront" that reads data directly from Supabase.
2. Backend (BoM Agent): Develop the BoM logic as a Python application (e.g., using FastAPI), package it in Docker, and deploy it on Google Cloud Run. This ensures scalability and cost-efficiency (pay-as-you-go).
3. Database & Auth: Use Supabase for database management, authentication, and RLS. This significantly simplifies backend development.
4. Main Application (PinPod): Develop a Flutter application, connect it to Supabase for real-time data and to the BoM Agent API for heavy-duty tasks.

## Next Steps

1. Setup Supabase: Create a new project in Supabase, define the table schemas (`users`, `pods`, `beans`), and set the RLS policy.
2. **Initial Development of the BoM Agent:** Create the first API endpoint in Python (for example, to upload files to IPFS) and deploy it to Google Cloud Run for testing.
3. **Initial Development of the PinPod App:** Connect the Flutter app to Supabase authentication and create a feature to read and display data from the `beans` table.
4. **End-to-End Integration:** Implement the complete "Bean" creation flow as described above to validate the architecture.